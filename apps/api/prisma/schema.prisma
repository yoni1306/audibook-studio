generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Book {
  id              String            @id @default(uuid())
  title           String
  author          String?
  language        String            @default("he")
  uploadedAt      DateTime          @default(now())
  s3Key           String            @unique // S3 key for the original EPUB
  status          BookStatus        @default(PROCESSING)
  
  // Original EPUB investigation fields
  epubMetadata    Json?             // Store original EPUB metadata (manifest, spine, etc.)
  processingLog   String?           @db.Text // Log of processing steps for debugging
  
  paragraphs      Paragraph[]
  rawChapters     RawChapter[]      // Store original chapter content for investigation
  textCorrections TextCorrection[]  // All text corrections for this book
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt

  @@map("books")
}

// New model to store original EPUB chapter content for investigation
model RawChapter {
  id            String   @id @default(uuid())
  bookId        String
  book          Book     @relation(fields: [bookId], references: [id], onDelete: Cascade)
  chapterNumber Int
  title         String?  // Chapter title if available
  href          String   // Original href from EPUB
  rawHtml       String   @db.Text // Original HTML content from EPUB
  extractedText String   @db.Text // Text extracted by our processor
  pageBlocks    Json?    // Store the page blocks as JSON for analysis
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@unique([bookId, chapterNumber])
  @@index([bookId])
  @@map("raw_chapters")
}

model Paragraph {
  id            String      @id @default(uuid())
  bookId        String
  book          Book        @relation(fields: [bookId], references: [id], onDelete: Cascade)
  chapterNumber Int
  orderIndex    Int         // Order within the book
  content       String      @db.Text
  
  // Investigation fields to track processing
  sourceChapter String?     // Reference to which raw chapter this came from
  sourceBlocks  Json?       // Store which page blocks contributed to this paragraph
  
  audioS3Key    String?     // S3 key for generated audio
  audioStatus   AudioStatus @default(PENDING)
  audioDuration Float?      // Duration in seconds
  textCorrections TextCorrection[]   // Track all text corrections for this paragraph
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt

  @@unique([bookId, orderIndex])
  @@index([bookId])
  @@map("paragraphs")
}

model TextCorrection {
  id              String    @id @default(uuid())
  paragraphId     String
  paragraph       Paragraph @relation(fields: [paragraphId], references: [id], onDelete: Cascade)
  bookId          String    // Direct reference to book for easier querying
  book            Book      @relation(fields: [bookId], references: [id], onDelete: Cascade)
  originalWord    String    // The specific word that was changed (e.g., "שלום")
  correctedWord   String    // What the word was changed to (e.g., "שָׁלוֹם")
  sentenceContext String    @db.Text // The full sentence context for better matching
  fixType         String?   // Optional categorization like 'niqqud', 'pronunciation', etc.
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  @@index([paragraphId])
  @@index([bookId])
  @@index([originalWord])
  @@index([correctedWord])
  @@index([originalWord, correctedWord])
  @@map("text_corrections")
}

enum BookStatus {
  UPLOADING
  PROCESSING
  READY
  ERROR
}

enum AudioStatus {
  PENDING
  GENERATING
  READY
  ERROR
}