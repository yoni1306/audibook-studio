{
  "version": 3,
  "sources": ["../../../../../../apps/workers/src/database.service.ts"],
  "sourcesContent": ["import { PrismaClient, BookStatus, AudioStatus } from '@prisma/client';\nimport { Logger } from '@nestjs/common';\n\nconst logger = new Logger('DatabaseService');\n\nconst prisma = new PrismaClient({\n  log: ['error', 'warn'],\n});\n\nexport async function saveParagraphs(\n  bookId: string,\n  paragraphs: Array<{\n    chapterNumber: number;\n    orderIndex: number;\n    content: string;\n  }>\n) {\n  try {\n    logger.log(`Saving ${paragraphs.length} paragraphs for book ${bookId}`);\n\n    // Save in batches to avoid overwhelming the database\n    const batchSize = 100;\n    for (let i = 0; i < paragraphs.length; i += batchSize) {\n      const batch = paragraphs.slice(i, i + batchSize);\n\n      await prisma.paragraph.createMany({\n        data: batch.map((p) => ({\n          bookId,\n          chapterNumber: p.chapterNumber,\n          orderIndex: p.orderIndex,\n          content: p.content,\n          audioStatus: AudioStatus.PENDING,\n        })),\n      });\n\n      logger.log(\n        `Saved batch ${Math.floor(i / batchSize) + 1}/${Math.ceil(\n          paragraphs.length / batchSize\n        )}`\n      );\n    }\n\n    logger.log(`Successfully saved all paragraphs for book ${bookId}`);\n  } catch (error) {\n    logger.error(`Failed to save paragraphs: ${error}`);\n    throw error;\n  }\n}\n\nexport async function updateBookStatus(bookId: string, status: BookStatus) {\n  try {\n    await prisma.book.update({\n      where: { id: bookId },\n      data: { status },\n    });\n    logger.log(`Updated book ${bookId} status to ${status}`);\n  } catch (error) {\n    logger.error(`Failed to update book status: ${error}`);\n    throw error;\n  }\n}\n\nexport async function updateParagraphAudio(\n  paragraphId: string,\n  audioS3Key: string,\n  audioDuration: number\n) {\n  try {\n    await prisma.paragraph.update({\n      where: { id: paragraphId },\n      data: {\n        audioS3Key,\n        audioDuration,\n        audioStatus: AudioStatus.READY,\n      },\n    });\n    logger.log(`Updated paragraph ${paragraphId} with audio`);\n  } catch (error) {\n    logger.error(`Failed to update paragraph audio: ${error}`);\n    throw error;\n  }\n}\n\n// Initialize connection\nprisma\n  .$connect()\n  .then(() => {\n    logger.log('Connected to database');\n  })\n  .catch((error) => {\n    logger.error('Failed to connect to database:', error);\n  });\n\nexport { prisma };\n"],
  "mappings": ";;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,oBAAsD;AACtD,oBAAuB;AAEvB,MAAM,SAAS,IAAI,qBAAO,iBAAiB;AAE3C,MAAM,SAAS,IAAI,2BAAa;AAAA,EAC9B,KAAK,CAAC,SAAS,MAAM;AACvB,CAAC;AAED,eAAsB,eACpB,QACA,YAKA;AACA,MAAI;AACF,WAAO,IAAI,UAAU,WAAW,MAAM,wBAAwB,MAAM,EAAE;AAGtE,UAAM,YAAY;AAClB,aAAS,IAAI,GAAG,IAAI,WAAW,QAAQ,KAAK,WAAW;AACrD,YAAM,QAAQ,WAAW,MAAM,GAAG,IAAI,SAAS;AAE/C,YAAM,OAAO,UAAU,WAAW;AAAA,QAChC,MAAM,MAAM,IAAI,CAAC,OAAO;AAAA,UACtB;AAAA,UACA,eAAe,EAAE;AAAA,UACjB,YAAY,EAAE;AAAA,UACd,SAAS,EAAE;AAAA,UACX,aAAa,0BAAY;AAAA,QAC3B,EAAE;AAAA,MACJ,CAAC;AAED,aAAO;AAAA,QACL,eAAe,KAAK,MAAM,IAAI,SAAS,IAAI,CAAC,IAAI,KAAK;AAAA,UACnD,WAAW,SAAS;AAAA,QACtB,CAAC;AAAA,MACH;AAAA,IACF;AAEA,WAAO,IAAI,8CAA8C,MAAM,EAAE;AAAA,EACnE,SAAS,OAAO;AACd,WAAO,MAAM,8BAA8B,KAAK,EAAE;AAClD,UAAM;AAAA,EACR;AACF;AAEA,eAAsB,iBAAiB,QAAgB,QAAoB;AACzE,MAAI;AACF,UAAM,OAAO,KAAK,OAAO;AAAA,MACvB,OAAO,EAAE,IAAI,OAAO;AAAA,MACpB,MAAM,EAAE,OAAO;AAAA,IACjB,CAAC;AACD,WAAO,IAAI,gBAAgB,MAAM,cAAc,MAAM,EAAE;AAAA,EACzD,SAAS,OAAO;AACd,WAAO,MAAM,iCAAiC,KAAK,EAAE;AACrD,UAAM;AAAA,EACR;AACF;AAEA,eAAsB,qBACpB,aACA,YACA,eACA;AACA,MAAI;AACF,UAAM,OAAO,UAAU,OAAO;AAAA,MAC5B,OAAO,EAAE,IAAI,YAAY;AAAA,MACzB,MAAM;AAAA,QACJ;AAAA,QACA;AAAA,QACA,aAAa,0BAAY;AAAA,MAC3B;AAAA,IACF,CAAC;AACD,WAAO,IAAI,qBAAqB,WAAW,aAAa;AAAA,EAC1D,SAAS,OAAO;AACd,WAAO,MAAM,qCAAqC,KAAK,EAAE;AACzD,UAAM;AAAA,EACR;AACF;AAGA,OACG,SAAS,EACT,KAAK,MAAM;AACV,SAAO,IAAI,uBAAuB;AACpC,CAAC,EACA,MAAM,CAAC,UAAU;AAChB,SAAO,MAAM,kCAAkC,KAAK;AACtD,CAAC;",
  "names": []
}
