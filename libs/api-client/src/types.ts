/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  '/': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * API information
     * @description Get basic information about the Audibook Studio API
     */
    get: operations['AppController_getData'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/health': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Health check
     * @description Check the health status of the API service
     */
    get: operations['HealthController_check'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/s3/upload': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Upload file directly through API
     * @description Upload file through API proxy to S3, eliminating CORS issues
     */
    post: operations['S3Controller_uploadFile'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/s3/presigned-upload': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get presigned upload URL
     * @description Generate a presigned URL for uploading files to S3
     */
    post: operations['S3Controller_getPresignedUploadUrl'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/books': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get all books
     * @description Retrieve all books in the system
     */
    get: operations['BooksController_getAllBooks'];
    put?: never;
    /**
     * Create a new book
     * @description Create a new book with title, author, and S3 key
     */
    post: operations['BooksController_createBook'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/books/fix-types': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get fix types
     * @description Get all available fix types for filtering corrections
     */
    get: operations['BooksController_getFixTypes'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/books/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get a book by ID
     * @description Retrieve a specific book with all its pages and paragraphs
     */
    get: operations['BooksController_getBook'];
    put?: never;
    post?: never;
    /**
     * Delete a book
     * @description Delete a book and all related entities (pages, paragraphs, text corrections) and associated S3 audio files
     */
    delete: operations['BooksController_deleteBook'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/books/{id}/completed-paragraphs': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get completed paragraphs for a book
     * @description Retrieve all completed paragraphs for a book, organized by page. Used for export preview and content verification.
     */
    get: operations['BooksController_getCompletedParagraphs'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/books/paragraphs/{paragraphId}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    /**
     * Update paragraph content
     * @description Update the content of a specific paragraph and optionally generate audio
     */
    patch: operations['BooksController_updateParagraph'];
    trace?: never;
  };
  '/books/paragraphs/{paragraphId}/revert': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Revert paragraph to original content
     * @description Revert a paragraph back to its original content from the source book
     */
    post: operations['BooksController_revertParagraph'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/books/paragraphs/{paragraphId}/diff': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get paragraph diff
     * @description Get the differences between current paragraph content and original content
     */
    get: operations['BooksController_getParagraphDiff'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/books/bulk-fixes': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Apply bulk text fixes
     * @description Apply multiple text fixes to a book
     */
    post: operations['BooksController_applyBulkFixes'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/books/paragraphs/{paragraphId}/suggested-fixes': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get suggested fixes for paragraph
     * @description Get suggested text fixes for a paragraph based on historical data
     */
    get: operations['BooksController_getSuggestedFixes'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/books/paragraphs/{paragraphId}/find-similar': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Find similar text fixes
     * @description Find similar text fixes for a paragraph based on word changes
     */
    post: operations['BooksController_findSimilarFixes'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/books/paragraphs/{paragraphId}/audio': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Stream paragraph audio
     * @description Get audio stream URL for a specific paragraph
     */
    get: operations['BooksController_streamAudio'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/books/correction-suggestions': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Get correction suggestions for text */
    post: operations['BooksController_getCorrectionSuggestions'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/books/correction-learning/stats': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get learning statistics
     * @description Get correction learning system statistics
     */
    get: operations['BooksController_getLearningStats'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/books/all-corrections': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get all corrections
     * @description Get all text corrections with optional filtering and pagination
     */
    post: operations['BooksController_getAllCorrections'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/books/word-corrections': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['BooksController_getWordCorrections'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/books/aggregated-corrections': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get aggregated text corrections
     * @description Get text corrections grouped by aggregation key (originalWord|correctedWord) with all contexts
     */
    post: operations['BooksController_getAggregatedCorrections'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/books/correction-history/{aggregationKey}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get correction history by aggregation key
     * @description Get all correction instances for a specific aggregation key (originalWord|correctedWord) with full context
     */
    get: operations['BooksController_getCorrectionHistory'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/books/{bookId}/paragraphs/{paragraphId}/completed': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    /**
     * Set paragraph completed status
     * @description Mark a paragraph as completed or not completed
     */
    patch: operations['BooksController_setParagraphCompleted'];
    trace?: never;
  };
  '/books/{id}/export/status': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get book export status
     * @description Get the current export status for a book, including page-level details
     */
    get: operations['BooksController_getBookExportStatus'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/books/{id}/export/start': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Start book export
     * @description Start the audio export process for a book. Combines completed paragraphs audio into page-level audio files.
     */
    post: operations['BooksController_startBookExport'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/books/{id}/pages/{pageId}/export': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Start page export
     * @description Start the audio export process for a specific page.
     */
    post: operations['BooksController_startPageExport'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/books/{id}/pages/{pageId}/cancel-export': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Cancel page export
     * @description Cancel the audio export process for a specific page.
     */
    post: operations['BooksController_cancelPageExport'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/books/{id}/pages/{pageId}/audio': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get page audio
     * @description Stream the exported audio file for a specific page.
     */
    get: operations['BooksController_getPageAudio'];
    put?: never;
    post?: never;
    /**
     * Delete page audio
     * @description Delete the exported audio file for a specific page.
     */
    delete: operations['BooksController_deletePageAudio'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/books/test-endpoint': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Test endpoint
     * @description Test endpoint to verify routing and API functionality
     */
    get: operations['BooksController_testEndpoint'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/text-fixes/paragraph/{paragraphId}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get paragraph text fixes
     * @description Get all text fixes for a specific paragraph
     */
    get: operations['TextFixesController_getParagraphFixes'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/text-fixes/book/{bookId}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get book text fixes
     * @description Get all text fixes for a specific book
     */
    get: operations['TextFixesController_getBookFixes'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/text-fixes/statistics': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get text fixes statistics
     * @description Get statistics about text fixes across all books
     */
    get: operations['TextFixesController_getStatistics'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/text-fixes/words': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get all word fixes
     * @description Get all unique word fixes across the system
     */
    get: operations['TextFixesController_getAllWordFixes'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/text-fixes/similar': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Find similar fixes
     * @description Find similar fixes for a given word
     */
    get: operations['TextFixesController_findSimilarFixes'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/queue/parse-epub': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Parse EPUB file
     * @description Add EPUB parsing job to the queue
     */
    post: operations['QueueController_addEpubParsingJob'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/queue/status': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get queue status
     * @description Get current status of the job queue
     */
    get: operations['QueueController_getQueueStatus'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/queue/jobs/{status}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get jobs by status
     * @description Get jobs filtered by their status
     */
    get: operations['QueueController_getJobsByStatus'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/queue/job/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get job by ID
     * @description Get detailed information about a specific job
     */
    get: operations['QueueController_getJob'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/queue/clean/{status}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post?: never;
    /**
     * Clean jobs by status
     * @description Clean/remove jobs with specified status from the queue
     */
    delete: operations['QueueController_cleanJobs'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/queue/retry/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Retry job
     * @description Retry a failed job by its ID
     */
    post: operations['QueueController_retryJob'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/logs': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Receive client logs
     * @description Receive and process logs from client applications
     */
    post: operations['LogsController_receiveLogs'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
}
export type webhooks = Record<string, never>;
export interface components {
  schemas: {
    PresignedUploadResponseDto: {
      /** @description Presigned upload URL */
      uploadUrl: string;
      /** @description S3 key for the uploaded file */
      key: string;
      /** @description ID of the created book */
      bookId: string;
      /** @description Original filename */
      filename: string;
      /** @description Response timestamp */
      timestamp: string;
    };
    GetFixTypesResponseDto: {
      /** @description Available fix types for filtering */
      fixTypes: string[];
      /** @description Response timestamp */
      timestamp?: string;
    };
    UpdateParagraphRequestDto: {
      /** @description New paragraph content */
      content: string;
      /**
       * @description Whether to generate audio for updated paragraph
       * @default false
       */
      generateAudio: boolean;
      /**
       * @description Whether to record text corrections for this update
       * @default true
       */
      recordTextCorrections: boolean;
    };
    TextChange: {
      /** @description Original word that was changed */
      originalWord: string;
      /** @description Corrected word */
      correctedWord: string;
      /** @description Position in text where change occurred */
      position: number;
    };
    BulkFixSuggestion: {
      /** @description Original word to be fixed */
      originalWord: string;
      /** @description Suggested corrected word */
      correctedWord: string;
      /** @description Array of paragraph IDs where this fix applies */
      paragraphIds: string[];
      /** @description Number of occurrences found */
      count: number;
      /** @description Preview text before the fix */
      previewBefore: string;
      /** @description Preview text after the fix */
      previewAfter: string;
      /** @description Detailed occurrences with context */
      occurrences: {
        paragraphId: string;
        previewBefore: string;
        previewAfter: string;
      }[];
      /** @description Full paragraph details for UI display */
      paragraphs: {
        id: string;
        pageId: string;
        pageNumber: number;
        orderIndex: number;
        content: string;
        occurrences: number;
        previewBefore: string;
        previewAfter: string;
      }[];
    };
    UpdateParagraphResponseDto: {
      /** @description Paragraph ID */
      id: string;
      /** @description Updated paragraph content */
      content: string;
      /**
       * @description Original paragraph content from the original book
       * @example זה הטקסט המקורי של הפסקה לפני כל שינוי
       */
      originalContent?: string;
      /**
       * @description Reference ID to the original paragraph in the original book
       * @example uuid-of-original-paragraph
       */
      originalParagraphId?: string;
      /** @description Book ID this paragraph belongs to */
      bookId: string;
      /** @description Text changes made */
      textChanges?: components['schemas']['TextChange'][];
      /** @description Text corrections applied */
      textFixes?: string[];
      /** @description Bulk fix suggestions found */
      bulkSuggestions?: components['schemas']['BulkFixSuggestion'][];
    };
    ParagraphInfoDto: {
      /** @description Paragraph ID */
      id: string;
      /** @description Paragraph content */
      content: string;
    };
    SuggestedFixDto: {
      /** @description Original word that could be fixed */
      originalWord: string;
      /** @description Suggested corrected word */
      suggestedWord: string;
      /** @description Confidence score for the suggestion (0-1) */
      confidence: number;
      /** @description Number of times this correction has been used */
      occurrences: number;
    };
    SuggestedFixesResponseDto: {
      /** @description Paragraph information */
      paragraph: components['schemas']['ParagraphInfoDto'];
      /** @description Whether paragraph was found */
      found: boolean;
      /** @description List of suggested fixes */
      suggestions: components['schemas']['SuggestedFixDto'][];
      /** @description Total number of suggestions */
      totalSuggestions: number;
      /** @description Response timestamp */
      timestamp: string;
    };
    GetCorrectionSuggestionsDto: {
      /** @description Text to analyze for correction suggestions */
      text: string;
      /**
       * @description Minimum occurrences for a suggestion
       * @default 2
       */
      minOccurrences: number;
    };
    CorrectionSuggestionDto: {
      /** @description Original word that was corrected */
      originalWord: string;
      /** @description Suggested corrected word */
      suggestedWord: string;
      /** @description Context sentence where the correction was used */
      contextSentence: string;
      /** @description Number of times this correction has been used */
      occurrenceCount: number;
      /** @description Type of fix applied */
      fixType?: string;
      /**
       * Format: date-time
       * @description Date when this correction was last used
       */
      lastUsed: string;
    };
    CorrectionSuggestionsResponseDto: {
      /** @description List of correction suggestions */
      suggestions: components['schemas']['CorrectionSuggestionDto'][];
      /** @description Total number of suggestions returned */
      totalSuggestions: number;
      /** @description Timestamp when suggestions were generated */
      timestamp?: string;
    };
    FiltersDto: {
      /** @description Filter by original word */
      originalWord?: string;
      /** @description Filter by corrected word */
      correctedWord?: string;
      /** @description Filter by fix type */
      fixType?: string;
      /** @description Filter by book ID */
      bookId?: string;
      /** @description Filter by book title */
      bookTitle?: string;
    };
    GetAllCorrectionsDto: {
      /** @description Filters for corrections */
      filters?: components['schemas']['FiltersDto'];
      /**
       * @description Page number
       * @default 1
       */
      page: number;
      /**
       * @description Number of items per page
       * @default 50
       */
      limit: number;
      /**
       * @description Sort field
       * @default createdAt
       * @enum {string}
       */
      sortBy: 'createdAt' | 'originalWord' | 'correctedWord';
      /**
       * @description Sort order
       * @default desc
       * @enum {string}
       */
      sortOrder: 'asc' | 'desc';
    };
    GetAllCorrectionsResponseDto: Record<string, never>;
    GetWordCorrectionsDto: {
      /** @description Original word to get corrections for */
      originalWord: string;
    };
    AggregatedCorrectionsRequestDto: {
      /** @description Filter by book ID */
      bookId?: string;
      /**
       * @description Filter by fix type
       * @enum {string}
       */
      fixType?:
        | 'vowelization'
        | 'disambiguation'
        | 'punctuation'
        | 'sentence_break'
        | 'dialogue_marking'
        | 'expansion'
        | 'default';
      /** @description Filter by original word */
      originalWord?: string;
      /** @description Filter by corrected word */
      correctedWord?: string;
      /** @description Filter by aggregation key */
      aggregationKey?: string;
      /** @description Minimum number of occurrences to include */
      minOccurrences?: number;
      /** @description Maximum number of results to return */
      limit?: number;
      /**
       * @description Sort order by creation date
       * @enum {string}
       */
      orderBy?: 'asc' | 'desc';
    };
    CorrectionInstanceDto: {
      /** @description Correction instance ID */
      id: string;
      /** @description Original word before correction */
      originalWord: string;
      /** @description Corrected word after correction */
      correctedWord: string;
      /** @description Sentence context where correction was applied */
      sentenceContext: string;
      /**
       * @description Type of correction applied
       * @enum {string}
       */
      fixType:
        | 'vowelization'
        | 'disambiguation'
        | 'punctuation'
        | 'sentence_break'
        | 'dialogue_marking'
        | 'expansion'
        | 'default';
      /** @description TTS model used for audio generation */
      ttsModel: string;
      /** @description TTS voice used for audio generation */
      ttsVoice: string;
      /**
       * Format: date-time
       * @description When the correction was created
       */
      createdAt: string;
      /** @description Book title where correction was applied */
      bookTitle: string;
      /** @description Book author */
      bookAuthor: string;
      /** @description Page number where correction was applied */
      pageNumber: number;
      /** @description Paragraph order index within the page */
      paragraphOrderIndex: number;
    };
    AggregatedCorrectionDto: {
      /** @description Aggregation key in format "originalWord|correctedWord" */
      aggregationKey: string;
      /** @description Original word before correction */
      originalWord: string;
      /** @description Corrected word after correction */
      correctedWord: string;
      /** @description Number of times this correction was applied */
      fixCount: number;
      /**
       * @description Type of correction
       * @enum {string}
       */
      fixType:
        | 'vowelization'
        | 'disambiguation'
        | 'punctuation'
        | 'sentence_break'
        | 'dialogue_marking'
        | 'expansion'
        | 'default';
      /**
       * Format: date-time
       * @description Most recent correction timestamp
       */
      lastCorrectionAt: string;
      /** @description All correction instances with full context */
      corrections: components['schemas']['CorrectionInstanceDto'][];
    };
    AggregatedCorrectionsResponseDto: {
      /** @description Aggregated corrections grouped by fix type */
      aggregatedCorrections: components['schemas']['AggregatedCorrectionDto'][];
      /** @description Total number of aggregated correction types */
      total: number;
      /** @description Response timestamp */
      timestamp: string;
    };
    WordCorrectionHistoryResponseDto: {
      /** @description Aggregation key (originalWord|correctedWord) */
      aggregationKey: string;
      /** @description Original word that was corrected */
      originalWord: string;
      /** @description Corrected word */
      correctedWord: string;
      /** @description All correction instances for this aggregation key */
      corrections: components['schemas']['CorrectionInstanceDto'][];
      /** @description Total number of correction instances */
      total: number;
      /** @description Response timestamp */
      timestamp: string;
    };
    PageExportStatusDto: {
      /**
       * @description Page ID
       * @example uuid-page-id
       */
      id: string;
      /**
       * @description Page number in the book
       * @example 1
       */
      pageNumber: number;
      /**
       * @description Number of completed paragraphs on this page
       * @example 3
       */
      completedParagraphsCount: number;
      /**
       * @description Total number of paragraphs on this page
       * @example 5
       */
      totalParagraphsCount: number;
      /**
       * @description Audio status for this page
       * @example READY
       * @enum {string}
       */
      audioStatus: 'PENDING' | 'GENERATING' | 'READY' | 'ERROR';
      /**
       * @description Duration of the combined audio in seconds
       * @example 45.5
       */
      audioDuration?: number;
      /**
       * @description S3 key for the combined page audio
       * @example books/book-id/pages/page-1-audio.mp3
       */
      audioS3Key?: string;
      /**
       * @description Whether this page will be included in export (has completed paragraphs)
       * @example true
       */
      willBeExported: boolean;
    };
    BookExportStatusDto: {
      /**
       * @description Book ID
       * @example uuid-book-id
       */
      bookId: string;
      /**
       * @description Book title
       * @example My Book Title
       */
      bookTitle: string;
      /**
       * @description Book author
       * @example Author Name
       */
      bookAuthor?: string;
      /**
       * @description Total number of pages in the book
       * @example 10
       */
      totalPages: number;
      /**
       * @description Number of pages that will be exported (have completed paragraphs)
       * @example 7
       */
      exportablePages: number;
      /**
       * @description Number of pages with audio generation in progress
       * @example 2
       */
      pagesInProgress: number;
      /**
       * @description Number of pages with ready audio
       * @example 5
       */
      pagesReady: number;
      /**
       * @description Number of pages with audio generation errors
       * @example 0
       */
      pagesWithErrors: number;
      /**
       * @description Overall export status
       * @example in_progress
       * @enum {string}
       */
      exportStatus:
        | 'not_started'
        | 'in_progress'
        | 'completed'
        | 'partial_errors'
        | 'failed';
      /** @description Detailed status for each page */
      pages: components['schemas']['PageExportStatusDto'][];
      /**
       * @description Total estimated duration of all exportable audio in seconds
       * @example 1200.5
       */
      totalDuration?: number;
      /**
       * @description Timestamp when export status was last updated
       * @example 2024-01-01T12:00:00Z
       */
      lastUpdated: string;
    };
    StartBookExportResponseDto: {
      /**
       * @description Whether the export was successfully started
       * @example true
       */
      success: boolean;
      /**
       * @description Message describing the result
       * @example Book export started successfully. 7 pages will be processed.
       */
      message: string;
      /**
       * @description Number of pages that will be processed
       * @example 7
       */
      pagesQueued: number;
      /**
       * @description Number of pages skipped (no completed paragraphs)
       * @example 3
       */
      pagesSkipped: number;
      /**
       * @description Job IDs for the queued audio generation tasks
       * @example [
       *       "job-1",
       *       "job-2",
       *       "job-3"
       *     ]
       */
      jobIds: string[];
      /**
       * @description Timestamp when export was started
       * @example 2024-01-01T12:00:00Z
       */
      timestamp: string;
    };
    JobDto: {
      /** @description Job ID */
      id: string;
      /** @description Job name */
      name: string;
      /** @description Job data */
      data: {
        [key: string]: unknown;
      };
      /** @description Job options */
      opts: {
        [key: string]: unknown;
      } | null;
      /** @description Job progress */
      progress: number | null;
      /** @description Job delay */
      delay: number | null;
      /** @description Job timestamp */
      timestamp: string;
      /** @description Job attempts made */
      attemptsMade: number;
      /** @description Job processed on */
      processedOn: string | null;
      /** @description Job finished on */
      finishedOn: string | null;
      /** @description Job failed reason */
      failedReason: string | null;
      /** @description Job stacktrace */
      stacktrace: string[] | null;
      /** @description Job return value */
      returnvalue: Record<string, never> | null;
    };
    GetJobsByStatusResponseDto: {
      /** @description List of jobs */
      jobs: components['schemas']['JobDto'][];
      /** @description Job status filter */
      status: string;
      /** @description Total number of jobs */
      total: number;
      /** @description Response timestamp */
      timestamp: string;
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
  AppController_getData: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successfully retrieved API information */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  HealthController_check: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Service is healthy */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  S3Controller_uploadFile: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description File upload (multipart/form-data) */
    requestBody: {
      content: {
        'multipart/form-data': {
          [key: string]: unknown;
        };
      };
    };
    responses: {
      /** @description File uploaded successfully */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  S3Controller_getPresignedUploadUrl: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description File upload details */
    requestBody: {
      content: {
        'application/json': {
          /** @description Name of the file to upload */
          filename: string;
          /** @description MIME type of the file */
          contentType: string;
        };
      };
    };
    responses: {
      /** @description Successfully generated presigned upload URL */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PresignedUploadResponseDto'];
        };
      };
    };
  };
  BooksController_getAllBooks: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successfully retrieved all books */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  BooksController_createBook: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Book creation data */
    requestBody: {
      content: {
        'application/json': {
          /** @description Book title */
          title: string;
          /** @description Book author (optional) */
          author?: string;
          /** @description S3 key for the book file */
          s3Key: string;
        };
      };
    };
    responses: {
      /** @description Book created successfully */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  BooksController_getFixTypes: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Fix types retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetFixTypesResponseDto'];
        };
      };
    };
  };
  BooksController_getBook: {
    parameters: {
      query?: {
        /** @description Filter paragraphs by completion status: all (default), completed, or incomplete */
        completedFilter?: string;
      };
      header?: never;
      path: {
        /** @description Book ID */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Book retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Book not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  BooksController_deleteBook: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Book ID to delete */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Book deleted successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Book not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Internal server error during deletion */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  BooksController_getCompletedParagraphs: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Book ID */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Completed paragraphs retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            bookId?: string;
            bookTitle?: string;
            pages?: {
              pageId?: string;
              pageNumber?: number;
              completedParagraphs?: {
                id?: string;
                content?: string;
                orderIndex?: number;
                audioStatus?: string;
                audioDuration?: number | null;
              }[];
            }[];
            totalCompletedParagraphs?: number;
            timestamp?: string;
          };
        };
      };
      /** @description Book not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  BooksController_updateParagraph: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paragraph ID */
        paragraphId: string;
      };
      cookie?: never;
    };
    /** @description Paragraph update data */
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateParagraphRequestDto'];
      };
    };
    responses: {
      /** @description Paragraph updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['UpdateParagraphResponseDto'];
        };
      };
    };
  };
  BooksController_revertParagraph: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paragraph ID */
        paragraphId: string;
      };
      cookie?: never;
    };
    /** @description Revert options */
    requestBody: {
      content: {
        'application/json': {
          /**
           * @description Whether to generate audio after reverting
           * @default false
           */
          generateAudio?: boolean;
        };
      };
    };
    responses: {
      /** @description Paragraph reverted successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['UpdateParagraphResponseDto'];
        };
      };
    };
  };
  BooksController_getParagraphDiff: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paragraph ID */
        paragraphId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Paragraph diff retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            changes?: {
              originalWord?: string;
              correctedWord?: string;
              position?: number;
              fixType?: string;
            }[];
            originalContent?: string;
            currentContent?: string;
          };
        };
      };
    };
  };
  BooksController_applyBulkFixes: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Bulk fixes data */
    requestBody: {
      content: {
        'application/json': {
          /** @description Book ID */
          bookId: string;
          fixes: {
            /** @description Original word to replace */
            originalWord: string;
            /** @description Corrected word */
            correctedWord: string;
            /** @description Paragraph IDs to apply fix to */
            paragraphIds: string[];
          }[];
        };
      };
    };
    responses: {
      /** @description Bulk fixes applied successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  BooksController_getSuggestedFixes: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paragraph ID */
        paragraphId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successfully retrieved suggested fixes */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SuggestedFixesResponseDto'];
        };
      };
    };
  };
  BooksController_findSimilarFixes: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paragraph ID */
        paragraphId: string;
      };
      cookie?: never;
    };
    /** @description Word changes to find similar fixes for */
    requestBody: {
      content: {
        'application/json': {
          wordChanges: {
            /** @description Original word */
            originalWord: string;
            /** @description Corrected word */
            correctedWord: string;
            /** @description Position in text */
            position: number;
          }[];
        };
      };
    };
    responses: {
      /** @description Successfully found similar fixes */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BulkFixSuggestion'][];
        };
      };
    };
  };
  BooksController_streamAudio: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paragraph ID */
        paragraphId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Redirect to audio stream URL */
      302: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  BooksController_getCorrectionSuggestions: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetCorrectionSuggestionsDto'];
      };
    };
    responses: {
      /** @description Correction suggestions retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CorrectionSuggestionsResponseDto'];
        };
      };
    };
  };
  BooksController_getLearningStats: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successfully retrieved learning statistics */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas'];
        };
      };
    };
  };
  BooksController_getAllCorrections: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetAllCorrectionsDto'];
      };
    };
    responses: {
      /** @description All corrections retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetAllCorrectionsResponseDto'];
        };
      };
    };
  };
  BooksController_getWordCorrections: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetWordCorrectionsDto'];
      };
    };
    responses: {
      201: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  BooksController_getAggregatedCorrections: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Aggregation filters */
    requestBody: {
      content: {
        'application/json': components['schemas']['AggregatedCorrectionsRequestDto'];
      };
    };
    responses: {
      /** @description Successfully retrieved aggregated corrections */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AggregatedCorrectionsResponseDto'];
        };
      };
    };
  };
  BooksController_getCorrectionHistory: {
    parameters: {
      query?: {
        /** @description Filter by book ID */
        bookId?: string;
      };
      header?: never;
      path: {
        /** @description Aggregation key (originalWord|correctedWord) to get history for */
        aggregationKey: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successfully retrieved correction history */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['WordCorrectionHistoryResponseDto'];
        };
      };
    };
  };
  BooksController_setParagraphCompleted: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ID of the book containing the paragraph */
        bookId: string;
        /** @description ID of the paragraph to update */
        paragraphId: string;
      };
      cookie?: never;
    };
    /** @description Completed status */
    requestBody: {
      content: {
        'application/json': {
          /** @description Whether the paragraph is completed */
          completed: boolean;
        };
      };
    };
    responses: {
      /** @description Paragraph completed status updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  BooksController_getBookExportStatus: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ID of the book to get export status for */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Book export status retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BookExportStatusDto'];
        };
      };
    };
  };
  BooksController_startBookExport: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ID of the book to export */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Book export started successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StartBookExportResponseDto'];
        };
      };
    };
  };
  BooksController_startPageExport: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ID of the book */
        id: string;
        /** @description ID of the page to export */
        pageId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Page export started successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StartBookExportResponseDto'];
        };
      };
    };
  };
  BooksController_cancelPageExport: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ID of the book */
        id: string;
        /** @description ID of the page */
        pageId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Export cancelled successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  BooksController_getPageAudio: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ID of the book */
        id: string;
        /** @description ID of the page */
        pageId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Audio file streamed successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  BooksController_deletePageAudio: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ID of the book */
        id: string;
        /** @description ID of the page */
        pageId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Page audio deleted successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  BooksController_testEndpoint: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Test endpoint response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  TextFixesController_getParagraphFixes: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paragraph ID */
        paragraphId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successfully retrieved paragraph text fixes */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  TextFixesController_getBookFixes: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Book ID */
        bookId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successfully retrieved book text fixes */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  TextFixesController_getStatistics: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successfully retrieved text fixes statistics */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  TextFixesController_getAllWordFixes: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successfully retrieved all word fixes */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  TextFixesController_findSimilarFixes: {
    parameters: {
      query: {
        /** @description Word to find similar fixes for */
        word: string;
        /** @description Maximum number of results to return */
        limit?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successfully found similar fixes */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  QueueController_addEpubParsingJob: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description EPUB parsing job data */
    requestBody: {
      content: {
        'application/json': {
          /** @description Book ID */
          bookId: string;
          /** @description S3 key for the EPUB file */
          s3Key: string;
        };
      };
    };
    responses: {
      /** @description EPUB parsing job added successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  QueueController_getQueueStatus: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successfully retrieved queue status */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  QueueController_getJobsByStatus: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Job status (waiting, active, completed, failed, delayed) */
        status: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successfully retrieved jobs by status */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetJobsByStatusResponseDto'];
        };
      };
    };
  };
  QueueController_getJob: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Job ID */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successfully retrieved job details */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  QueueController_cleanJobs: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Job status to clean (completed, failed) */
        status: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successfully cleaned jobs */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  QueueController_retryJob: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Job ID to retry */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successfully retried job */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  LogsController_receiveLogs: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Client logs data */
    requestBody: {
      content: {
        'application/json': {
          logs: Record<string, never>[];
        };
      };
    };
    responses: {
      /** @description Successfully processed client logs */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
}
