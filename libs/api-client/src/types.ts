/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  '/': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * API information
     * @description Get basic information about the Audibook Studio API
     */
    get: operations['AppController_getData'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/health': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Health check
     * @description Check the health status of the API service
     */
    get: operations['HealthController_check'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/s3/presigned-upload': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get presigned upload URL
     * @description Generate a presigned URL for uploading files to S3
     */
    post: operations['S3Controller_getPresignedUploadUrl'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/books': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get all books
     * @description Retrieve all books in the system
     */
    get: operations['BooksController_getAllBooks'];
    put?: never;
    /**
     * Create a new book
     * @description Create a new book with title, author, and S3 key
     */
    post: operations['BooksController_createBook'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/books/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get book by ID
     * @description Retrieve a specific book by its ID
     */
    get: operations['BooksController_getBook'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/books/paragraphs/{paragraphId}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    /**
     * Update paragraph content
     * @description Update the content of a specific paragraph and optionally generate audio
     */
    patch: operations['BooksController_updateParagraph'];
    trace?: never;
  };
  '/books/bulk-fixes': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Apply bulk text fixes
     * @description Apply multiple text fixes to a book
     */
    post: operations['BooksController_applyBulkFixes'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/books/paragraphs/{paragraphId}/suggested-fixes': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get suggested fixes for paragraph
     * @description Get suggested text fixes for a paragraph based on historical data
     */
    get: operations['BooksController_getSuggestedFixes'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/books/paragraphs/{paragraphId}/find-similar': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Find similar text fixes
     * @description Find similar text fixes for a paragraph based on word changes
     */
    post: operations['BooksController_findSimilarFixes'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/books/paragraphs/{paragraphId}/audio': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Stream paragraph audio
     * @description Get audio stream URL for a specific paragraph
     */
    get: operations['BooksController_streamAudio'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/books/correction-suggestions': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Get correction suggestions for text */
    post: operations['BooksController_getCorrectionSuggestions'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/books/correction-learning/stats': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get learning statistics
     * @description Get correction learning system statistics
     */
    get: operations['BooksController_getLearningStats'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/books/fix-types': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get fix types
     * @description Get all available fix types for filtering corrections
     */
    get: operations['BooksController_getFixTypes'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/books/all-corrections': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get all corrections
     * @description Get all text corrections with optional filtering and pagination
     */
    post: operations['BooksController_getAllCorrections'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/books/word-corrections': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations['BooksController_getWordCorrections'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/books/test-endpoint': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Test endpoint
     * @description Test endpoint to verify routing and API functionality
     */
    get: operations['BooksController_testEndpoint'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/text-fixes/paragraph/{paragraphId}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get paragraph text fixes
     * @description Get all text fixes for a specific paragraph
     */
    get: operations['TextFixesController_getParagraphFixes'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/text-fixes/book/{bookId}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get book text fixes
     * @description Get all text fixes for a specific book
     */
    get: operations['TextFixesController_getBookFixes'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/text-fixes/statistics': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get text fixes statistics
     * @description Get statistics about text fixes across all books
     */
    get: operations['TextFixesController_getStatistics'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/text-fixes/words': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get all word fixes
     * @description Get all unique word fixes across the system
     */
    get: operations['TextFixesController_getAllWordFixes'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/text-fixes/similar': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Find similar fixes
     * @description Find similar fixes for a given word
     */
    get: operations['TextFixesController_findSimilarFixes'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/queue/parse-epub': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Parse EPUB file
     * @description Add EPUB parsing job to the queue
     */
    post: operations['QueueController_addEpubParsingJob'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/queue/status': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get queue status
     * @description Get current status of the job queue
     */
    get: operations['QueueController_getQueueStatus'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/queue/jobs/{status}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get jobs by status
     * @description Get jobs filtered by their status
     */
    get: operations['QueueController_getJobsByStatus'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/queue/job/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get job by ID
     * @description Get detailed information about a specific job
     */
    get: operations['QueueController_getJob'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/queue/clean/{status}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post?: never;
    /**
     * Clean jobs by status
     * @description Clean/remove jobs with specified status from the queue
     */
    delete: operations['QueueController_cleanJobs'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/queue/retry/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Retry job
     * @description Retry a failed job by its ID
     */
    post: operations['QueueController_retryJob'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/logs': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Receive client logs
     * @description Receive and process logs from client applications
     */
    post: operations['LogsController_receiveLogs'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
}
export type webhooks = Record<string, never>;
export interface components {
  schemas: {
    PresignedUploadResponseDto: {
      /** @description Presigned upload URL */
      uploadUrl: string;
      /** @description S3 key for the uploaded file */
      key: string;
      /** @description ID of the created book */
      bookId: string;
      /** @description Original filename */
      filename: string;
      /** @description Response timestamp */
      timestamp: string;
    };
    UpdateParagraphRequestDto: {
      /** @description New paragraph content */
      content: string;
      /**
       * @description Whether to generate audio for updated paragraph
       * @default false
       */
      generateAudio: boolean;
    };
    TextChange: {
      /** @description Original word that was changed */
      originalWord: string;
      /** @description Corrected word */
      correctedWord: string;
      /** @description Position in text where change occurred */
      position: number;
    };
    BulkFixSuggestion: {
      /** @description Original word to be fixed */
      originalWord: string;
      /** @description Suggested corrected word */
      correctedWord: string;
      /** @description Array of paragraph IDs where this fix applies */
      paragraphIds: string[];
      /** @description Number of occurrences found */
      count: number;
      /** @description Preview text before the fix */
      previewBefore: string;
      /** @description Preview text after the fix */
      previewAfter: string;
      /** @description Detailed occurrences with context */
      occurrences: {
        paragraphId: string;
        previewBefore: string;
        previewAfter: string;
      }[];
      /** @description Full paragraph details for UI display */
      paragraphs: {
        id: string;
        pageId: string;
        pageNumber: number;
        orderIndex: number;
        content: string;
        occurrences: number;
        previewBefore: string;
        previewAfter: string;
      }[];
    };
    UpdateParagraphResponseDto: {
      /** @description Paragraph ID */
      id: string;
      /** @description Updated paragraph content */
      content: string;
      /** @description Book ID this paragraph belongs to */
      bookId: string;
      /** @description Text changes made */
      textChanges?: components['schemas']['TextChange'][];
      /** @description Text corrections applied */
      textFixes?: string[];
      /** @description Bulk fix suggestions found */
      bulkSuggestions?: components['schemas']['BulkFixSuggestion'][];
    };
    ParagraphInfoDto: {
      /** @description Paragraph ID */
      id: string;
      /** @description Paragraph content */
      content: string;
    };
    SuggestedFixDto: {
      /** @description Original word that could be fixed */
      originalWord: string;
      /** @description Suggested corrected word */
      suggestedWord: string;
      /** @description Confidence score for the suggestion (0-1) */
      confidence: number;
      /** @description Number of times this correction has been used */
      occurrences: number;
    };
    SuggestedFixesResponseDto: {
      /** @description Paragraph information */
      paragraph: components['schemas']['ParagraphInfoDto'];
      /** @description Whether paragraph was found */
      found: boolean;
      /** @description List of suggested fixes */
      suggestions: components['schemas']['SuggestedFixDto'][];
      /** @description Total number of suggestions */
      totalSuggestions: number;
      /** @description Response timestamp */
      timestamp: string;
    };
    GetCorrectionSuggestionsDto: {
      /** @description Text to analyze for correction suggestions */
      text: string;
      /**
       * @description Minimum occurrences for a suggestion
       * @default 2
       */
      minOccurrences: number;
    };
    CorrectionSuggestionDto: {
      /** @description Original word that was corrected */
      originalWord: string;
      /** @description Suggested corrected word */
      suggestedWord: string;
      /** @description Context sentence where the correction was used */
      contextSentence: string;
      /** @description Number of times this correction has been used */
      occurrenceCount: number;
      /** @description Type of fix applied */
      fixType?: string;
      /**
       * Format: date-time
       * @description Date when this correction was last used
       */
      lastUsed: string;
    };
    CorrectionSuggestionsResponseDto: {
      /** @description List of correction suggestions */
      suggestions: components['schemas']['CorrectionSuggestionDto'][];
      /** @description Total number of suggestions returned */
      totalSuggestions: number;
      /** @description Timestamp when suggestions were generated */
      timestamp?: string;
    };
    GetFixTypesResponseDto: {
      /** @description Available fix types for filtering */
      fixTypes: string[];
      /** @description Response timestamp */
      timestamp?: string;
    };
    FiltersDto: {
      /** @description Filter by original word */
      originalWord?: string;
      /** @description Filter by corrected word */
      correctedWord?: string;
      /** @description Filter by fix type */
      fixType?: string;
      /** @description Filter by book ID */
      bookId?: string;
      /** @description Filter by book title */
      bookTitle?: string;
    };
    GetAllCorrectionsDto: {
      /** @description Filters for corrections */
      filters?: components['schemas']['FiltersDto'];
      /**
       * @description Page number
       * @default 1
       */
      page: number;
      /**
       * @description Number of items per page
       * @default 50
       */
      limit: number;
      /**
       * @description Sort field
       * @default createdAt
       * @enum {string}
       */
      sortBy: 'createdAt' | 'originalWord' | 'correctedWord';
      /**
       * @description Sort order
       * @default desc
       * @enum {string}
       */
      sortOrder: 'asc' | 'desc';
    };
    GetAllCorrectionsResponseDto: Record<string, never>;
    GetWordCorrectionsDto: {
      /** @description Original word to get corrections for */
      originalWord: string;
    };
    JobDto: {
      /** @description Job ID */
      id: string;
      /** @description Job name */
      name: string;
      /** @description Job data */
      data: {
        [key: string]: unknown;
      };
      /** @description Job options */
      opts: {
        [key: string]: unknown;
      } | null;
      /** @description Job progress */
      progress: number | null;
      /** @description Job delay */
      delay: number | null;
      /** @description Job timestamp */
      timestamp: string;
      /** @description Job attempts made */
      attemptsMade: number;
      /** @description Job processed on */
      processedOn: string | null;
      /** @description Job finished on */
      finishedOn: string | null;
      /** @description Job failed reason */
      failedReason: string | null;
      /** @description Job stacktrace */
      stacktrace: string[] | null;
      /** @description Job return value */
      returnvalue: Record<string, never> | null;
    };
    GetJobsByStatusResponseDto: {
      /** @description List of jobs */
      jobs: components['schemas']['JobDto'][];
      /** @description Job status filter */
      status: string;
      /** @description Total number of jobs */
      total: number;
      /** @description Response timestamp */
      timestamp: string;
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
  AppController_getData: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successfully retrieved API information */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  HealthController_check: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Service is healthy */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  S3Controller_getPresignedUploadUrl: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description File upload details */
    requestBody: {
      content: {
        'application/json': {
          /** @description Name of the file to upload */
          filename: string;
          /** @description MIME type of the file */
          contentType: string;
        };
      };
    };
    responses: {
      /** @description Successfully generated presigned upload URL */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PresignedUploadResponseDto'];
        };
      };
    };
  };
  BooksController_getAllBooks: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successfully retrieved all books */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  BooksController_createBook: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Book creation data */
    requestBody: {
      content: {
        'application/json': {
          /** @description Book title */
          title: string;
          /** @description Book author (optional) */
          author?: string;
          /** @description S3 key for the book file */
          s3Key: string;
        };
      };
    };
    responses: {
      /** @description Book created successfully */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  BooksController_getBook: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Book ID */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successfully retrieved book */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  BooksController_updateParagraph: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paragraph ID */
        paragraphId: string;
      };
      cookie?: never;
    };
    /** @description Paragraph update data */
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateParagraphRequestDto'];
      };
    };
    responses: {
      /** @description Paragraph updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['UpdateParagraphResponseDto'];
        };
      };
    };
  };
  BooksController_applyBulkFixes: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Bulk fixes data */
    requestBody: {
      content: {
        'application/json': {
          /** @description Book ID */
          bookId: string;
          fixes: {
            /** @description Original word to replace */
            originalWord: string;
            /** @description Corrected word */
            correctedWord: string;
            /** @description Paragraph IDs to apply fix to */
            paragraphIds: string[];
          }[];
        };
      };
    };
    responses: {
      /** @description Bulk fixes applied successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  BooksController_getSuggestedFixes: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paragraph ID */
        paragraphId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successfully retrieved suggested fixes */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SuggestedFixesResponseDto'];
        };
      };
    };
  };
  BooksController_findSimilarFixes: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paragraph ID */
        paragraphId: string;
      };
      cookie?: never;
    };
    /** @description Word changes to find similar fixes for */
    requestBody: {
      content: {
        'application/json': {
          wordChanges: {
            /** @description Original word */
            originalWord: string;
            /** @description Corrected word */
            correctedWord: string;
            /** @description Position in text */
            position: number;
          }[];
        };
      };
    };
    responses: {
      /** @description Successfully found similar fixes */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BulkFixSuggestion'][];
        };
      };
    };
  };
  BooksController_streamAudio: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paragraph ID */
        paragraphId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Redirect to audio stream URL */
      302: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  BooksController_getCorrectionSuggestions: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetCorrectionSuggestionsDto'];
      };
    };
    responses: {
      /** @description Correction suggestions retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CorrectionSuggestionsResponseDto'];
        };
      };
    };
  };
  BooksController_getLearningStats: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successfully retrieved learning statistics */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas'];
        };
      };
    };
  };
  BooksController_getFixTypes: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Fix types retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetFixTypesResponseDto'];
        };
      };
    };
  };
  BooksController_getAllCorrections: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetAllCorrectionsDto'];
      };
    };
    responses: {
      /** @description All corrections retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetAllCorrectionsResponseDto'];
        };
      };
    };
  };
  BooksController_getWordCorrections: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetWordCorrectionsDto'];
      };
    };
    responses: {
      201: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  BooksController_testEndpoint: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Test endpoint response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  TextFixesController_getParagraphFixes: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paragraph ID */
        paragraphId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successfully retrieved paragraph text fixes */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  TextFixesController_getBookFixes: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Book ID */
        bookId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successfully retrieved book text fixes */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  TextFixesController_getStatistics: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successfully retrieved text fixes statistics */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  TextFixesController_getAllWordFixes: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successfully retrieved all word fixes */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  TextFixesController_findSimilarFixes: {
    parameters: {
      query: {
        /** @description Word to find similar fixes for */
        word: string;
        /** @description Maximum number of results to return */
        limit?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successfully found similar fixes */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  QueueController_addEpubParsingJob: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description EPUB parsing job data */
    requestBody: {
      content: {
        'application/json': {
          /** @description Book ID */
          bookId: string;
          /** @description S3 key for the EPUB file */
          s3Key: string;
        };
      };
    };
    responses: {
      /** @description EPUB parsing job added successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  QueueController_getQueueStatus: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successfully retrieved queue status */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  QueueController_getJobsByStatus: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Job status (waiting, active, completed, failed, delayed) */
        status: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successfully retrieved jobs by status */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetJobsByStatusResponseDto'];
        };
      };
    };
  };
  QueueController_getJob: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Job ID */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successfully retrieved job details */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  QueueController_cleanJobs: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Job status to clean (completed, failed) */
        status: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successfully cleaned jobs */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  QueueController_retryJob: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Job ID to retry */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successfully retried job */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  LogsController_receiveLogs: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Client logs data */
    requestBody: {
      content: {
        'application/json': {
          logs: Record<string, never>[];
        };
      };
    };
    responses: {
      /** @description Successfully processed client logs */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
}
